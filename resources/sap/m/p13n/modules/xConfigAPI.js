/*!
 * OpenUI5
 * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
 * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
 */
sap.ui.define(["sap/base/util/merge","sap/ui/core/util/reflection/JsControlTreeModifier"],(e,t)=>{"use strict";const n={};n.enhanceConfig=(o,r)=>{const a=r.propertyBag;const i=a?a.modifier:t;let s;let g;return i.getControlMetadata(o).then(e=>{s=e;r.controlMetadata=s;return i.getAggregation(o,"customData")}).then(e=>Promise.all(e.map(e=>i.getProperty(e,"key"))).then(t=>e.reduce((e,n,o)=>t[o]==="xConfig"?n:e,undefined))).then(t=>{g=t;if(g){return i.getProperty(g,"value").then(t=>e({},JSON.parse(t.replace(/\\/g,""))))}return{}}).then(async t=>{let s;if(r.controlMeta&&r.controlMeta.aggregation){await n.prepareAggregationConfig(o,r,t);s=n.createAggregationConfig(o,r,t)}else{s=n.createPropertyConfig(o,r,t)}if(r.markAsModified){s.modified=true}const c=a?a.appComponent:undefined;let p=Promise.resolve();if(g&&o.isA){p=i.removeAggregation(o,"customData",g).then(()=>i.destroy(g))}return p.then(()=>i.createAndAddCustomData(o,"xConfig",JSON.stringify(s),c).then(()=>e({},s)))})};async function o(e,t){const n=e.map(t);const o=await Promise.all(n);const r=o.findIndex(e=>e);return e[r]}n.getCurrentItemState=async function(e,t,n,r){const a=t?.changeType;if(!t.propertyBag||!a||a.indexOf("Item")===-1){return}const{modifier:i,appComponent:s}=t.propertyBag;const g=await i.getAggregation(e,r);const c=g||[];const p=[];if(n&&Object.keys(n.aggregations[r]).length>0){Object.entries(n.aggregations[r]).forEach(([e,t])=>{if(t.visible!==false){p.push({key:e,position:t.position})}});p.sort((e,t)=>e.position-t.position);p.map(e=>delete e.position)}else{await c.reduce(async(e,t,n)=>{const r=await e;const a=await i.getAggregation(t,"customData");const g=await o(a,async e=>await i.getProperty(e,"key")==="p13nKey");if(g){const e=await i.getProperty(g,"value");const n=await i.getProperty(t,"visible");if(n&&e){p.push({key:e})}}else{const e=s?s.getRootControl()?.getLocalId(i.getId(t)):i.getId(t);const n=await i.getProperty(t,"visible");if(n&&e){p.push({key:e})}}return r},Promise.resolve())}return p};n.readConfig=(n,o)=>{if(o){const r=o.propertyBag?o.propertyBag.modifier:t;return r.getAggregation(n,"customData").then(e=>Promise.all(e.map(e=>r.getProperty(e,"key"))).then(t=>e.reduce((e,n,o)=>t[o]==="xConfig"?n:e,undefined))).then(t=>{if(t){return r.getProperty(t,"value").then(t=>e({},JSON.parse(t.replace(/\\/g,""))))}return null})}const r=(e,t)=>{const n=(e,t)=>{if(e){if(e.getMetadata){const n=e.getMetadata();const o=n.getAllAggregations();if(o){return o[t]}}}return undefined};const o=n(e,t);if(o){return e[o._sGetter]()}return undefined};const a=(e,t)=>{const n=e.getMetadata().getPropertyLikeSetting(t);if(n){const t=n._sGetter;return e[t]()}return undefined};const i=r(n,"customData").find(e=>a(e,"key")=="xConfig");const s=i?e({},JSON.parse(a(i,"value").replace(/\\/g,""))):null;return s};const r=function(t,n,o){const r=o.key||o.name;const a=o.controlMeta;const i=o.value;const s=o.controlMetadata||t.getMetadata();const g=a.aggregation;const c=g?g:s.getDefaultAggregation().name;const{currentState:p}=o;const f=i.index;const{operation:d}=o;const l=e([],p);const u={add:(e,t)=>{l.splice(t,0,{key:e})},remove:(e,t)=>{const n=l?.find(t=>t.key==e);const o=l?.indexOf(n);if(o>-1){l.splice(o,1)}},move:(e,t)=>{const n=l?.find(t=>t.key==e);const o=l?.indexOf(n);if(o>-1){const[e]=l.splice(o,1);l.splice(t,0,e)}}};if(p instanceof Array&&d&&u[d]instanceof Function){u[d](r,f)}l.forEach((e,t)=>{const o=n.aggregations[c]?.[e.key];if(o&&o.hasOwnProperty("position")){o.position=t}else if(!o){const o=p?.findIndex(t=>t.key===e.key);if(t!==undefined&&o!==t&&t!==-1){n.aggregations[c][e.key]={position:t}}}})};n.prepareAggregationConfig=async(e,t,o)=>{const r=t.controlMeta;const a=t.controlMetadata||e.getMetadata();const i=r.aggregation;const s=i?i:a.getDefaultAggregation().name;const g=o||{};if(!g.hasOwnProperty("aggregations")){g.aggregations={}}if(!g.aggregations.hasOwnProperty(s)){if(a.hasAggregation(s)){g.aggregations[s]={};const o=await n.getCurrentItemState(e,t,g,s);o?.forEach(e=>{g.aggregations[s][e.key]={position:e.position}})}else{throw new Error("The aggregation "+s+" does not exist for"+e)}}t.currentState=t.currentState||await n.getCurrentItemState(e,t,g,s)};n.createAggregationConfig=(e,t,n)=>{const o=t.key||t.name;const a=t.controlMeta;const i=t.property;const s=t.value;const g=t.controlMetadata||e.getMetadata();const c=a.aggregation;const p=c?c:g.getDefaultAggregation().name;const f=n||{};if(!f.hasOwnProperty("aggregations")){f.aggregations={}}if(!f.aggregations.hasOwnProperty(p)){if(g.hasAggregation(p)){f.aggregations[p]={}}else{throw new Error("The aggregation "+p+" does not exist for"+e)}}if(!f.aggregations[p].hasOwnProperty(o)){f.aggregations[p][o]={}}if(s!==null||s&&s.hasOwnProperty("value")&&s.value!==null){switch(t.operation){case"move":f.aggregations[p][o][i]=s.index;if(s.persistenceIdentifier){f.aggregations[p][o]["persistenceIdentifier"]=s.persistenceIdentifier}r(e,f,t);break;case"remove":case"add":default:if(s.hasOwnProperty("value")){f.aggregations[p][o][i]=s.value;if(s.index!==undefined){f.aggregations[p][o]["position"]=s.index}if(s.persistenceIdentifier){f.aggregations[p][o]["persistenceIdentifier"]=s.persistenceIdentifier}}else{f.aggregations[p][o][i]=s}r(e,f,t);break}}else{delete f.aggregations[p][o][i];if(Object.keys(f.aggregations[p][o]).length===0){delete f.aggregations[p][o];if(Object.keys(f.aggregations[p]).length===0){delete f.aggregations[p]}}}return f};n.createPropertyConfig=(e,t,n)=>{const o=t.value;const r=t.property;const a=n||{};if(!a.properties){a.properties={}}if(!a.properties.hasOwnProperty(r)){a.properties[r]=[]}const i=t.operation;const s=a.properties[r].find(e=>e.key===t.key);if(s&&i!=="add"){a.properties[r].splice(a.properties[r].indexOf(s),1)}if(i!=="remove"){a.properties[r].splice(t.value.index,0,o)}return a};return n});
//# sourceMappingURL=xConfigAPI.js.map